#pragma once

#include <libscapi/include/cryptoInfra/Protocol.hpp>
#include "../../primitives/CheatingRecoveryCircuitCreator.hpp"
#include "../../primitives/KProbeResistantMatrix.hpp"
#include "../../primitives/ExecutionParameters.hpp"
#include "../../primitives/CryptoPrimitives.hpp"
#include "../primitives/BucketLimitedBundleList.hpp"
#include "../../primitives/CommunicationConfig.hpp"
#include "../primitives/EvaluationPackage.hpp"
#include "../../common/KeyUtils.hpp"
#include "../../primitives/CircuitOutput.hpp"
#include "../subroutines/OnlineComputeRoutine.hpp"
#include "../../primitives/CutAndChooseSelection.hpp"



/**
* This class represents the second party in the online phase of Malicious Yao protocol. 
*
* The full protocol specification is described in "Blazing Fast 2PC in the "Offline/Online Setting with Security for
* Malicious Adversaries" paper by Yehuda Lindell and Ben Riva, page 20 - FIGURE E.3 (The Online Stage).
*
* @author Cryptography and Computer Security Research Group Department of Computer Science Bar-Ilan University
*
*/
class OnlineProtocolP2 : public Protocol, public Malicious, public TwoParty {

private:
    //set io_service for peer to peer communication
    boost::asio::io_service io_service;
	ExecutionParameters mainExecution;		// Parameters of the main circuit.
	ExecutionParameters crExecution;		// Parameters of the cheating recovery circuit.
	unique_ptr<CmtSimpleHashReceiver> cmtReceiver;		//The receiver of the commitment protocol used to verify the decommitments.
	shared_ptr<CommParty> channel;			//Used to communicate between the parties.

	int keyLength;							//The length of each secret key in bytes.

	unique_ptr<OnlineComputeRoutine> computeRoutine;	//The instance that computes the main circuit.

	/*
	* The buckets to use in the online protocol.
	* The buckets contain some circuits to evaluate.
	*/
	shared_ptr<BucketLimitedBundle> mainBucket;			//Contain the main circuits (for ex. AES).		
	shared_ptr<BucketLimitedBundle> crBucket;			//Contain the cheating recovery circuits.
	KProbeResistantMatrix* mainMatrix;		//The probe-resistant matrix used to restore the main circuit's keys.
	KProbeResistantMatrix* crMatrix;			//The probe-resistant matrix used to restore the cheating recovery circuit's keys.

	CircuitInput input;						//The input for the main circuit.

	/*
	* The following members are received from p1 in order to detect cheating in the protocol.
	*/
	SecretKey proofOfCheating;						//Generated by p1 and sent to p2 in order to detect cheating.
	SecretKey hashedProof;							//The result of the hash function on the proof of cheating.
	vector<vector<vector<block>>> proofCiphers;

	CircuitEvaluationResult evaluationResult;		// Indicates if a cheating was caught or not.
	vector<byte> mainOutput;								//The output of the main circuit.
	vector<byte> crOutput;								//The output of the cheating recovery circuit.

	/**
	* Computes the main circuits part.
	*
	* pseudo code:
	* 1. Receive the requested input from p2
	* 2. Send the commitment masks
	* 3. Decommit of p2 input wires' keys
	* 4. Send the xor of the placement mask with the input
	* 5. Decommit of p1 input wires' keys
	* 6. Select and encrypt proof to send to p2
	* @throws IOException
	*/
	void evaluateMainCircuit();

	void evaluateCheatingRecoveryCircuit();

	/**
	* Receives the package from p1. This package contain all the necessary messages during the protocol.
	* This gives better performance than sending each message separately.
	* @return The received message.
	* @throws CheatAttemptException In case the received message is not an EvaluationPackage instance.
	* @throws IOException If there as a problem during the communication.
	*/
	EvaluationPackage receivePackage();

	/**
	* Computes the xor of the given input and the y1 keys that were generated in the offline protocol.
	* Sends the result to the other party and returns it.
	* @param bucket The bucket to work on.
	* @param y The input for the circuit.
	* @return The result of the xor of the given input and the y1 keys
	* @throws IOException If there as a problem during the communication.
	*/
	vector<byte> selectAndSendY2(BucketLimitedBundle* bucket, CircuitInput & y);
	
	/**
	* Extract the commitment mask of each circuit in the bucket from the received evaluationPackage and put it in the circuit.
	* @param bucket The bucket to work on.
	* @param evaluationPackage The message that was received from p1.
	*/
	void receiveCommitmentMasks(BucketLimitedBundle* bucket, EvaluationPackage & evaluationPackage);

	/**
	* Verifies that the received decommitments on the input keys are correct.
	* In case they are, extract the keys and sets them in the circuits.
	* In case the user enable threads, this function is split into the number of threads as the user requested.
	* @param bucket The bucket to work on.
	* @param evaluationPackage The message that was received from p1.
	* @param matrix The probe resistant matrix to use in order to restore the original keys from the extended keys.
	* @param y2 The boolean input for the circuit.
	*/
	void receiveAndVerifyY2InputKeys(BucketLimitedBundle* bucket, EvaluationPackage & evaluationPackage, KProbeResistantMatrix * matrix, vector<byte> & y2);

	/**
	* Verifies that the received decommitments on the input keys are correct.
	* In case they are, extract the keys and sets them in the circuits.
	* @param bucket The bucket to work on.
	* @param evaluationPackage The message that was received from p1.
	* @param matrix The probe resistant matrix to use in order to restore the original keys from the extended keys.
	* @param y2 The boolean input for the circuit.
	* @param from The starting index in the bucket that point on the first circuit to work on.
	* @param to The last index in the bucket that point on the last circuit to work on.
	*/
	void verifyY2InputKeys(BucketLimitedBundle* bucket, EvaluationPackage * evaluationPackage,
		KProbeResistantMatrix * matrix, vector<byte> * y2, int from, int to, int threadIndex);
	
	/**
	* Checks that the given random values and committed values are indeed lead to the commitments values.
	* @param comm The commitments values.
	* @param r The random values used to commit.
	* @param x The values to commit on.
	* @return true if the commitments match the values and randoms; false, otherwise.
	*/
	bool verifyDecommitment(CryptographicHash* hash, vector<byte> & comm, vector<byte> & r, vector<byte> & x);

	/**
	* Gets the keys and mask and xor each key with the mask.
	* The result is placed in the keys array.
	* @param keys The keys to xor with the mask. This content is changed during the method and the output is places here.
	* @param mask The mask to use in order to xor each key.
	* @param size The number of keys.
	*/
	void xorKeysWithMask(block* keys, int size, vector<byte> & maskArray);

	/**
	* verifies that the received decommitments on the d2 input keys are correct.
	* @param bucket The bucket to work on.
	* @param matrix The probe resistant matrix to use in order to restore the original keys from the extended keys.
	* @param evaluationPackage The message that was received from p1.
	* @param d2 The boolean input for the cheating recovery circuit.
	*/
	void receiveAndVerifyD2InputKeys(BucketLimitedBundle * bucket, EvaluationPackage & evaluationPackage, KProbeResistantMatrix * matrix, vector<byte> & d2);

	/**
	* Receive the placement mask and check that the difference is as expected.
	* @param bucket The bucket to work on.
	* @param evaluationPackage The message that was received from p1.
	*/
	void receivePlacementMasks(BucketLimitedBundle * bucket, EvaluationPackage & evaluationPackage);

	/**
	* Verifies that the received decommitments on the x input keys are correct.
	* In case they are, extract the keys and sets them in the circuits.
	* @param bucket The bucket to work on.
	* @param evaluationPackage The message that was received from p1.
	*/
	void receiveAndVerifyXInputKeys(BucketLimitedBundle * bucket, EvaluationPackage & evaluationPackage);

	/**
	* Extract from the received package the encrypted proof of cheating.
	* @param bucket The bucket to work on.
	* @param evaluationPackage The message that was received from p1.
	*/
	void receiveEncryptedProof(BucketLimitedBundle* bucket, EvaluationPackage & evaluationPackage);

	/**
	* Computes the main circuit.
	* @param bucket The bucket to work on.
	*/
	void computeEvaluationCircuits(const shared_ptr<BucketLimitedBundle> & bucket);

	/**
	* Verifies the decommitment on the output keys that were received from p1.
	* @param bucket The bucket to work on.
	* @param evaluationPackage The message that was received from p1.
	*/
	void receiveAndVerifyOutputKeys(BucketLimitedBundle* bucket, EvaluationPackage & evaluationPackage);

	/**
	* Computes the cheating recovery circuit.
	* @param bucket The bucket to work on.
	*/
	void computeCheatingRecoveryCircuit(const shared_ptr<BucketLimitedBundle> & bucket);

public:
	/**
	* Constructor that sets the parameters.
	*
	*/
	OnlineProtocolP2(int argc, char* argv[]);

    ~OnlineProtocolP2(){
        //end communication
        io_service.stop();
    }

    void setBuckets(const shared_ptr<BucketLimitedBundle> & mainBucket, const shared_ptr<BucketLimitedBundle> & crBucket);
	void setInput(CircuitInput & protocolInput) { input = protocolInput; }

    shared_ptr<GarbledBooleanCircuit> getMainCircuit(){ return mainExecution.getCircuit(0); }

	/**
	* Executes the second party of the online protocol.<p>
	* basically, it computes the main circuit and than the cheating recovery circuit.
	*/
	void run() override {
        runOnline();
    }
    bool hasOffline() override {return false; }
    bool hasOnline() override {return true; }
    void runOnline() override;
    shared_ptr<CommParty> getChannel(){ return channel; }

	/**
	* Get the output of the protocol.
	*/
	CircuitOutput getOutput();
};
